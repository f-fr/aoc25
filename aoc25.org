#+LATEX_COMPILER: lualatex
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmainfont{Noto Serif}
#+LATEX_HEADER: \usepackage[left=1cm, right=1cm, top=2cm, bottom=2cm]{geometry}
#+LATEX_HEADER: \setminted{bgcolor=black!5!white}

#+TITLE: Advent of code 2025
#+AUTHOR: fifr
#+EMAIL:
#+LANGUAGE: en
#+OPTIONS: toc:nil

This is a short write up of my Advent-of-Code-2025 solutions. The main
purpose is to collect my ideas when looking again at the puzzles some
time in the future.

* Day 1
First we read the input line by line, extracting the direction and the step size.

#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
// Advent of code 25 - day 1
const std = @import("std");
const aoc = @import("aoc");

pub fn run(_: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var pos: i16 = 50;
    var score1: u32 = 0;
    var score2: u32 = 0;
    while (try lines.next()) |line| {
        if (line.len == 0) continue; // skip empty lines
        const sign: i16 =
            switch (line[0]) {
                'R' => 1,
                'L' => -1,
                else => return error.InvalidDirection,
            };
        const d = try std.fmt.parseInt(i16, line[1..], 10);
#+END_SRC
The new position is then
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        const new_pos = @mod(pos + sign * d, 100);
#+END_SRC
The score computation for part 1 is simple: check if the new position is 0.
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        if (new_pos == 0) score1 += 1;
#+END_SRC
For part 2 we consider two cases:
   1. Forward direction if ~sign > 0~
   2. Backward direction if ~sign < 0~
The first case is easy. If the new position is ~new_pos = old_pos + d =
100 * a + b~, then number of times we pass "0" is ~a~, hence
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        if (sign > 0) score2 += @abs(@divFloor(pos + d, 100)) // fwd
#+END_SRC
However, if we move in backward direction, the new position would be
negative and the division computation would be wrong if the new (or
the old) position is exactly "0". Therefore, we use a little trick:
for the computation of the part 2 score we mirror position and
direction such that we can use the forward computation again. In
particular, we use ~mirror_pos = (100 - pos) % 100~ to mirror the
position and ~new_mirror_pos = mirror_pos + d = 100 * a + b~ for the score
computation.
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        else score2 += @abs(@divFloor(@mod(100 - pos, 100) + d, 100)); // bwd
#+END_SRC
Finally, update the current position
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        pos = @intCast(new_pos);
    }
#+END_SRC
and return the result
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 2
We start by reading the input line by line, where "lines" are
separated by commas. The each line is split into two parts separated by "-".

#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
const std = @import("std");
const aoc = @import("aoc");

const powi = std.math.powi;

pub fn run(allocator: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    lines.delimiter = ',';

    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const alloc = arena.allocator();

    var score1: u64 = 0;
    // invalid ids for part 2
    var invalids: std.ArrayList(u64) = .empty;

    while (try lines.next()) |rng| {
        const toks = try aoc.splitN(2, std.mem.trim(u8, rng, " \t\r\n"), "-");
#+END_SRC
Next we determine the number of digits of both numbers as well as
the numbers themselves.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
        const d1 = toks[0].len;
        const d2 = toks[1].len;

        const x = try std.fmt.parseUnsigned(u64, toks[0], 10);
        const y = try std.fmt.parseUnsigned(u64, toks[1], 10);
#+END_SRC
The idea is now to try each possible block size ~d~, which is used to
built the repeated patterns. The minimal possible block size is 1, the
maximal block size is $\lceil d_2/2 \rceil$ because we have to use at
least two blocks.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
        for (1..d2 / 2 + 1) |d| {
#+END_SRC
For a given block size ~d~ we compute a corresponding block
factor ~f~ by $f=10^d$.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
            const f = try powi(u64, 10, d); // block size as 10^d
#+END_SRC
Furthermore we compute the minimal and the maximal /number/ of blocks
(each of size ~d~) to be used. The minimal number is used to form ~x~, the
maximal number to form ~y~, hence
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
            const k_min = @max(2, (d1 - 1) / d + 1); // minimal number of blocks
            const k_max = d2 / d; // maximal number of blocks

            for (k_min..k_max + 1) |k| {
#+END_SRC
Now, for a given block size ~d~ and block count ~k~ we can construct all
possible numbers following the repeated pattern. Let ~z~ be value
representing one block. Then the repeated number can be computed
as \[z \cdot f^0 + z \cdot f^1 + \ldots + z \cdot f^{k-1} = z \cdot
\sum_{i=0}^{k-1} f^i\]
Using
\[ q = \sum_{i=0}^{k-1} f^i = \frac{f^k - 1}{f - 1} \]
the number is exactly $z \cdot q$.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                // block multiplicator
                const q = (try powi(u64, f, k) - 1) / (f - 1);
#+END_SRC
A valid block value must not be smaller than $\lceil x / q \rceil$ and not be
larger than $\lfloor y / q \rfloor$. Furthermore, because a block
must not start with a leading zero, the minimal possible block value
is \[f / 10 = \underbrace{10\ldots 0}_{d\text{ digits}}\]
and the maximal value is
\[f - 10 = \underbrace{99\ldots 9}_{d\text{ digits}}.\] Hence, we
can compute the minimal and maximal possible block values by
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                // minimal value based on x and on block-size (no leading zeros)
                const a = @max((x - 1) / q + 1, f / 10);
                // maximal value based on y and on block-size (no leading zeros)
                const b = @min(y / q, f - 1);
#+END_SRC
If the interval is empty, there is nothing to do
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                if (a > b) continue;
#+END_SRC
For part 1 we only consider the case of exactly two blocks. In that
case we compute the sum of all possible numbers formed by blocks in
$\{a, \ldots, b\}$, i.e.
\[ \sum_{z=a}^b z \cdot q = q \cdot \sum_{z=a}^b z = q \cdot \frac{b(b+1) - a(a-1)}2. \]
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                if (k == 2) {
                    // all values in between match (hopefully)
                    score1 += (b * (b + 1) - a * (a - 1)) / 2 * q;
                }
#+END_SRC
For part 2 we simply collect all invalid ids
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                // because there may be duplicates, we simply count
                var z = a;
                while (z <= b) : (z += 1) try invalids.append(alloc, z * q);
            }
        }
    }
#+END_SRC
The remaining step is to sum the invalid ids for part2. We must take
care of possible duplicate values, i.e. some numbers can be found by
different block sizes (e.g. an invalid id ~111111111~ is found by block
sizes 1, 2 and 4). Therefore, we sort the invalid ids and
count each one only if it differs from its predecessor in the ordered
list:
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
    aoc.sort(u64, invalids.items);
    var score2: u64 = if (invalids.items.len == 0) 0 else invalids.items[0];
    for (invalids.items[0 .. invalids.items.len - 1], invalids.items[1..]) |x, y| {
        if (x != y) score2 += y;
    }
#+END_SRC
That's is, we can return the results.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 3
The main observation is that the most significant digit of a number
must be as large as possible. Hence, we can choose the most
significant digit such that it is as large as possible as long as
there are sufficiently many remaining digits to the right.

We start again be reading the input line by line and ensure it has
enough digits for part 2.
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(_: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var score1: u64 = 0;
    var score2: u64 = 0;
    while (try lines.next()) |line| {
        if (line.len < 12) return error.LineTooShort;
#+END_SRC
For part 1 we look for the first occurrence of the largest digit
except for the last digit in that line (because that one cannot be the
first of two digits in the result).
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        const i = std.mem.indexOfMax(u8, line[0 .. line.len - 1]);
#+END_SRC
Next we look for the largest digit to the right of the first one
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        const j = std.mem.indexOfMax(u8, line[i + 1 ..]) + i + 1;
#+END_SRC
And we can already compute the result for part 1 using these two digits
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        score1 += (line[i] - '0') * 10 + (line[j] - '0');
#+END_SRC

For part 2 we use the same strategy, but we have to ensure that there
are enough remaining digits to the right. So for the first digit
we do not look at the last 11 digits in that line. For the second
digit we do not look at the last 10 digits in that line and so on.
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        var start: usize = 0;
        for (0..12) |k| {
            const idx = std.mem.indexOfMax(u8, line[start .. line.len - 11 + k]) + start;
            start = idx + 1; // for the next digit start to the right of this one
#+END_SRC
We can add each digit to the result immediately because the \((k+1)\)-th
most significant digit ~x~ contributes exactly $x \cdot 10^{11-k}$ to
the final sum.
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
            score2 += try std.math.powi(u64, 10, 11 - k) * (line[idx] - '0');
        }
    }

    return .{ score1, score2 };
}
#+END_SRC

* Day 4
We start by reading the input grid. In order to simplify the computation, we add
a boundary of empty squares.
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(alloc: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var arena = std.heap.ArenaAllocator.init(alloc);
    defer arena.deinit();
    const a = arena.allocator();

    // read grid with boundary of empty squares
    var g = try lines.readGridWithBoundary(a, '.');
#+END_SRC
Now we compute for each square the number of ~@~ neighbors (including
itself). For empty squares we set the number of neighbors to something
large. This allows us to recognize (and ignore) empty squares later by
only looking at that square's degree. Squares with degree < 4 can be
removed. We collect all of them in a list ~removable~.
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    var degrees = try aoc.Grid.initWith(a, g.n, g.m, 42);
    var removable: std.ArrayList(aoc.Pos) = .empty;
    for (1..g.n - 1) |i| {
        for (1..g.m - 1) |j| {
            if (g.at(i, j) == '@') {
                var d: u8 = 0;
                for (i - 1..i + 2) |y| {
                    for (j - 1..j + 2) |x| {
                        if (g.at(y, x) == '@') d += 1;
                    }
                }
                degrees.set(i, j, d);
                // d - 1 because we count the square itself
                if (d - 1 < 4) try removable.append(a, .{ .i = i, .j = j });
            }
        }
    }
#+END_SRC
The number of removable squares is already the score for part 1.
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    const score1 = removable.items.len;
#+END_SRC
For part 2 we remove the removable squares one by one. When we remove
a square we update the degrees of all of its neighbors (i.e. we reduce
the neighbor's degree by one each). If the degree of a neighbor drops
below 4 for the first time, that square can be removed as well, so it
is appended to the list of removable squares. 
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    var score2: usize = 0;
    while (removable.pop()) |pos| {
        score2 += 1; // the score is the number of all removed squares
        const i = pos.i;
        const j = pos.j;
        for (i - 1..i + 2) |y| {
            for (j - 1..j + 2) |x| {
                const deg = degrees.at(y, x);
                if (deg - 1 == 4) {
                    // degree drops below 4, so remove this
                    // neighbor as well
                    try removable.append(a, .{ .i = y, .j = x });
                    // mark this square as empty
                }
                degrees.set(y, x, deg - 1);
            }
        }
    }
#+END_SRC
That's it, we can return the solution
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 5
The main idea is too keep all "interesting" numbers in a single ordered list.
Interesting numbers are
- start of an interval
- end of an interval
- id of an ingredient
We then order this list of numbers are traverse is from smallest to
largest. At the same time we keep track of the number of "open"
intervals, i.e. of those intervals whose start has already been seen
but whose end has not been seen, yet. If we find an "id", we can
easily check if it is contained in one currently open interval.

Several of these numbers may be equal. We need to distinguish if a
number is start or end of an interval or if it is an id. Furthermore,
because the intervals are inclusive, we have to ensure that we always
see interval starts first, then the id and then the interval ends. For
this we do not store a number $x$ itself in the list but $x \cdot f + c$
where $f$ is an integer at least 3 and $c$ is either 0, 1 or 2 depending on
if $x$ is a interval start, id or interval end, respectively.

We start by reading the intervals and append all numbers to the list ~nums~
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(alloc: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var arena = std.heap.ArenaAllocator.init(alloc);
    defer arena.deinit();
    const a = arena.allocator();

    const F = 4;
    var nums: std.ArrayList(u64) = .empty;
    while (try lines.next()) |line| {
        if (line.len == 0) break; // stop at the first empty line
        const ns = try aoc.toNums(u64, 2, line, "-");
        try nums.append(a, ns[0] * F); // opening
        try nums.append(a, ns[1] * F + 2); // closing
        if (ns[0] > ns[1]) return error.InvalidRange;
    }
#+END_SRC
Next we read the list of ids and append them as well
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
    while (try lines.next()) |line| {
        const id = try aoc.toNum(u64, line);
        try nums.append(a, id * F + 1); // id
    }
#+END_SRC
Now we sort the list of numbers
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
    aoc.sort(u64, nums.items);
#+END_SRC
and traverse them in order. While doing so we keep track of the number
of open intervals ~nopen~ at the current point as well as start of the
first currently open interval ~start~.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
    var score1: usize = 0;
    var score2: u64 = 0;
    var nopen: usize = 0;
    var start: u64 = 0;
    for (nums.items) |x| {
#+END_SRC
If the number is an interval start, we increase the number of open
intervals and possibly store the start position (if it is the first
open interval).
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
        if (x % F == 0) {
            if (nopen == 0) start = x / F;
            nopen += 1;
#+END_SRC
If the number is an interval end, we decrease the number of open
intervals. If it is the last open interval, we know that all
numbers from ~start~ to the current position are "fresh" and we
add their count to the score of part 2.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
        } else if (x % F == 2) {
            nopen -= 1;
            if (nopen == 0) score2 += (x / F - start + 1);
#+END_SRC
Otherwise the number is an id. If there is currently at least one open
interval, the id is "fresh" and we increment the score for part 1.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
        } else if (nopen > 0) {
            score1 += 1;
        }
    }
#+END_SRC
That's it, we return the results.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig

    return .{ score1, score2 };
}
#+END_SRC

* TODO Day 6
We start by reading the input as character grid.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(alloc: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var arena = std.heap.ArenaAllocator.init(alloc);
    defer arena.deinit();
    const a = arena.allocator();

    var g = try lines.readGridFilled(a, ' ');
#+END_SRC
This might be surprising, but for part2 it is very convenient.
Furthermore, a grid can also be used as a list of (text) lines.

The last line contains the operators, so we extract this line from the
grid.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    var ops = try aoc.splitA(a, g.row(g.n - 1), " ");
    // ignore last row
    g.n -= 1;
#+END_SRC
We compute all "columns" in parallel. For each column we start with the
first number.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    var nums = try aoc.toNumsA(u64, a, g.row(0), " ");
#+END_SRC
Now we iterate through for all subsequent rows and split it into a
sequence of numbers (one for each column).
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    for (1..g.n) |i| {
        var toks = std.mem.tokenizeSequence(u8, g.row(i), " ");
#+END_SRC
Now we combine each number with the accumulated number of the
respective column (either addition or multiplication).
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
        var j: usize = 0;
        while (toks.next()) |tok| {
            if (ops[j][0] == '+')
                nums[j] += try aoc.toNum(u32, tok)
            else
                nums[j] *= try aoc.toNum(u32, tok);
            j += 1;
        }
    }
#+END_SRC
For part 1 it remains to sum all accumulated numbers.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    var score1: u64 = 0;
    for (nums) |n| score1 += n;
#+END_SRC
Part 2 is very similar, but the numbers have to be read "downwards".
The easiest way to get them in "normal form" is to rotate the grid
90 degrees counter clockwise.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    var g2 = try g.rotateLeft(a);
#+END_SRC
The lines of the rotate grid correspond to the single numbers. The
numbers of one follow in succession, the numbers of different
exercises are separated by (at least) one empty line (where empty lines
means that it contains only spaces). Furthermore, the first exercise
in the rotate grid corresponds to the right-most exercise in the original grid,
so the operators must be used from right to left as well. We use two variables
~i~ and ~j~ where ~i~ is the current row and ~j~ is the current exercise.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    var i: usize = 0;
    var j: usize = 0;
#+END_SRC
Now iterate through all exercises computing the score for part 2
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    var score2: u64 = 0;
    while (j < ops.len) : (j += 1) {
#+END_SRC
If the operator is a "+" we need to sum up the numbers of this
exercise
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
        if (ops[ops.len - j - 1][0] == '+') {
            var s: u64 = 0;
            while (i < g2.n) : (i += 1) {
                s += aoc.toNum(u32, g2.row(i)) catch break;
            }
            score2 += s;
#+END_SRC
Note that the conversion to a number will fail if the line is empty,
hence we can detect the end of the current exercise by looking at
the error condition of ~aoc.toNum~.

If the operator is a "*" the computation is the same except that we
multiply all numbers.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
        } else {
            var p: u64 = 1;
            while (i < g2.n) : (i += 1) {
                p *= aoc.toNum(u32, g2.row(i)) catch break;
            }
            score2 += p;
        }
#+END_SRC
Finally, we skip all empty lines to find the start of the next exercise.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig

        // skip empty lines
        while (i < g2.n and std.mem.trim(u8, g2.row(i), " ").len == 0) i += 1;
    }
#+END_SRC
It remains to return the results.
#+BEGIN_SRC zig -i :exports code :tangle src/06/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 7
This exercise can be solved line by line. We start by looking for the first
line containing the starting point. We also store the length of this line.
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(alloc: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var arena = std.heap.ArenaAllocator.init(alloc);
    defer arena.deinit();
    const a = arena.allocator();

    var m: usize = 0;
    const s = start: while (try lines.next()) |line| {
        if (std.mem.findScalar(u8, line, 'S')) |j| {
            m = line.len;
            break :start j;
        }
    } else return error.MissingStart;
#+END_SRC
In each iteration we compute the number of tachyons in each field of
the next line. For this we keep the number of tachyons in each field
of the current in an array ~cur~ and compute the values for the next
line in ~nxt~. Note that both arrays are of size ~m+2~ so we keep one
additional (empty) field at the boundaries and we do not have to deal
with special cases anymore.
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
    var cur = try a.alloc(u64, m + 2);
    var nxt = try a.alloc(u64, m + 2);
#+END_SRC
The starting line contains exactly one tachyon in the starting position
and zero everywhere else.
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
    @memset(cur, 0);
    cur[s + 1] = 1;
#+END_SRC
Now we run run through all lines.
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
    var score1: usize = 0;
    while (try lines.next()) |line| {
        if (line.len != m) return error.InvalidLineLen;
#+END_SRC
We initialize the values for the next line to ~zero~
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
        @memset(nxt, 0);
#+END_SRC
Next we inspect all fields of the next line one by one
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
        for (line, 1..) |c, j| {
            switch (c) {
#+END_SRC
According to the rules, if a field contains a dot it contains
exactly the number of tachyons from the field above
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
                '.' => nxt[j] += cur[j],
#+END_SRC
Otherwise, if the field contains a splitter, we do to things. First
we increase the number of times a tachyon is split (score of part 1).
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
                '^' => {
                    score1 += @intFromBool(cur[j] > 0);
#+END_SRC
Second, the value of the field above is added to the fields left and
right of the splitter.
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
                    nxt[j - 1] += cur[j];
                    nxt[j + 1] += cur[j];
                },
#+END_SRC
No other character is allowed in a valid input.
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
                else => return error.InvalidChar,
            }
        }
#+END_SRC
After finishing the current line, the next values become the new
current values of the next line. Hence, we swap the ~cur~ and ~nxt~ arrays.
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
        std.mem.swap([]u64, &cur, &nxt);
    }
#+END_SRC
All that remains to do for part 2 is to sum the number of all tachyons
in the final line (now contained in ~cur~)
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
    var score2: u64 = 0;
    for (cur) |x| score2 += x;
#+END_SRC
And return the results
#+BEGIN_SRC zig -i :exports code :tangle src/07/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 8
This is basically Kruskal's algorithm running on a complete graph. For
this we need two parts, a union-find data structure and a sorting
algorithm. The union-find data structure is not really critical
because the number of nodes (hence the numbers of "unions") is
relatively small. Nevertheless, we use the usual union-by-rank data
structure with path compression.
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
const std = @import("std");
const aoc = @import("aoc");

const UnionFind = struct {
    parent: []usize,
    rank: []usize,

    fn init(a: std.mem.Allocator, n: usize) !@This() {
        const p = try a.alloc(usize, n);
        const r = try a.alloc(usize, n);
        for (p, 0..) |*x, i| x.* = i;
        @memset(r, 0);
        return .{ .parent = p, .rank = r };
    }

    fn find(self: *@This(), u: usize) usize {
        const p = self.parent[u];
        if (p == u) return u;
        const new_p = self.find(p);
        self.parent[u] = new_p;
        return new_p;
    }

    fn union_(self: *@This(), u: usize, v: usize) bool {
        const pu = self.find(u);
        const pv = self.find(v);
        if (pu == pv) return false;
        switch (std.math.order(self.rank[pu], self.rank[pv])) {
            .lt => self.parent[pu] = pv,
            .gt => self.parent[pv] = pu,
            .eq => {
                self.parent[pv] = pu;
                self.rank[pu] += 1;
            },
        }
        return true;
    }
};
#+END_SRC
Kruskal's algorithm is typically dominated by sorting the edges by
length. Because the number of edges is large (it's a complete graph)
but the number of edges in the tree is quite small, it is likely that
we do not need to sort all edges. Hence, we basically use heap-sort to
only extract the edges with the shortest length as needed. For this, we
need the ~downHeap~ operation:
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
const Elem = struct { len: u64, idx: usize };

fn downHeap(heap: []Elem, idx: usize) void {
    const x = heap[idx];
    var i = idx;
    var j = 2 * i + 1;
    while (j + 1 < heap.len) : (j = 2 * i + 1) {
        const k = j + @intFromBool(heap[j + 1].len < heap[j].len);
        if (heap[k].len >= x.len) break;
        heap[i] = heap[k];
        i = k;
    }
    if (j + 1 == heap.len and heap[j].len < heap[i].len) {
        heap[i] = heap[j];
        i = j;
    }
    heap[i] = x;
}
#+END_SRC
Here ~Elem~ is an element on the heap containing the edge index
and the edge length.

Now we are ready to state the main algorithm. We start by reading
the coordinates of all nodes.
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
pub fn run(alloc: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var arena = std.heap.ArenaAllocator.init(alloc);
    defer arena.deinit();
    const a = arena.allocator();

    const Pnt = @Vector(3, i64);
    var pnts: std.ArrayList(Pnt) = .empty;

    while (try lines.next()) |line| {
        try pnts.append(a, try aoc.toNums(i32, 3, line, ","));
    }
#+END_SRC
Next we compute all edges lengths. Actually, we store the square
of each edge length, which is still an integer (so no need to
compute a square root). Furthermore, we store the two end nodes
of each edge for easy access.
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
    const n = pnts.items.len;
    var m = n * (n - 1) / 2;
    const Edge = [2]u16;

    var edges = try a.alloc(Edge, m);
    var lens = try a.alloc(Elem, m);
    {
        var e: usize = 0;
        for (pnts.items, 0..) |p, u| {
            for (pnts.items[u + 1 ..], u + 1..) |q, v| {
                edges[e] = .{ @intCast(u), @intCast(v) };
                lens[e] = .{
                    .idx = e,
                    .len = @intCast(@reduce(.Add, (p - q) * (p - q))),
                };
                e += 1;
            }
        }
    }
#+END_SRC
We initialize the heap in the variable ~lens~
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
    for (m / 2..m) |i| downHeap(lens, m - i - 1);
#+END_SRC
and the union-find data structure
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
    var uf = try UnionFind.init(a, n);
    var ncomponents: usize = n;
#+END_SRC
For the test cases (small graphs) we run Kruskal's algorithm
for only 10 iterations (for part 1) and for 1000 iterations
otherwise.
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
    const niter: usize = if (n < 100) 10 else 1000;
    var score1: u64 = 0;
    var score2: u64 = 0;
    var iter: usize = 0;
#+END_SRC
Now run Kruskal's algorithm. We track the number of remaining edges
in the variable ~m~
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
    while (m > 0) {
        iter += 1;
#+END_SRC
Extract the next edge from the heap
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
        const e_len = lens[0];
        m -= 1;
        lens[0] = lens[m];
        downHeap(lens[0..m], 0);
#+END_SRC
Unite the components of both end nodes
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
        const u = edges[e_len.idx][0];
        const v = edges[e_len.idx][1];

        if (uf.union_(u, v)) {
            ncomponents -= 1;
#+END_SRC
If the two nodes have been in different components the number of
components is decreased by 1. If the number components drops to one we
found a spanning tree. This gives the score for part 2 and
we can stop the algorithm.
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
            if (ncomponents == 1) {
                score2 = @intCast(pnts.items[u][0] * pnts.items[v][0]);
                break;
            }
        }
#+END_SRC
For part 1 we check if the required number of iterations has
been reached. If this is the case, compute the score for
part 1. For this, we simply count the number of nodes in
each component, sort the component sizes and extract the
three largest ones.
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
        if (iter == niter) {
            var sizes = try a.alloc(usize, n);
            defer a.free(sizes);
            @memset(sizes, 0);
            for (0..n) |i| sizes[uf.find(i)] += 1;
            aoc.sort(usize, sizes);
            score1 = sizes[n - 3] * sizes[n - 2] * sizes[n - 1];
        }
#+END_SRC
That's it, we can return the scores.
#+BEGIN_SRC zig -i :exports code :tangle src/08/run.zig
    }

    return .{ score1, score2 };
}
#+END_SRC

# Local Variables:
# jinx-languages: "en_US"
# End:
