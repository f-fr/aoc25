#+LATEX_COMPILER: lualatex
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmainfont{Noto Serif}
#+LATEX_HEADER: \usepackage[left=1cm, right=1cm, top=2cm, bottom=2cm]{geometry}
#+LATEX_HEADER: \setminted{bgcolor=black!5!white}

#+TITLE: Advent of code 2025
#+AUTHOR: fifr
#+EMAIL:
#+LANGUAGE: en
#+OPTIONS: toc:nil

This is a short write up of my Advent-of-Code-2025 solutions. The main
purpose is to collect my ideas when looking again at the puzzles some
time in the future.

* Day 1
First we read the input line by line, extracting the direction and the step size.

#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
// Advent of code 25 - day 1
const std = @import("std");
const aoc = @import("aoc");

pub fn run(_: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var pos: i16 = 50;
    var score1: u32 = 0;
    var score2: u32 = 0;
    while (try lines.next()) |line| {
        if (line.len == 0) continue; // skip empty lines
        const sign: i16 =
            switch (line[0]) {
                'R' => 1,
                'L' => -1,
                else => return error.InvalidDirection,
            };
        const d = try std.fmt.parseInt(i16, line[1..], 10);
#+END_SRC
The new position is then
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        const new_pos = @mod(pos + sign * d, 100);
#+END_SRC
The score computation for part 1 is simple: check if the new position is 0.
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        if (new_pos == 0) score1 += 1;
#+END_SRC
For part 2 we consider two cases:
   1. Forward direction if ~sign > 0~
   2. Backward direction if ~sign < 0~
The first case is easy. If the new position is ~new_pos = old_pos + d =
100 * a + b~, then number of times we pass "0" is ~a~, hence
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        if (sign > 0) score2 += @abs(@divFloor(pos + d, 100)) // fwd
#+END_SRC
However, if we move in backward direction, the new position would be
negative and the division computation would be wrong if the new (or
the old) position is exactly "0". Therefore, we use a little trick:
for the computation of the part 2 score we mirror position and
direction such that we can use the forward computation again. In
particular, we use ~mirror_pos = (100 - pos) % 100~ to mirror the
position and ~new_mirror_pos = mirror_pos + d = 100 * a + b~ for the score
computation.
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        else score2 += @abs(@divFloor(@mod(100 - pos, 100) + d, 100)); // bwd
#+END_SRC
Finally, update the current position
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
        pos = @intCast(new_pos);
    }
#+END_SRC
and return the result
#+BEGIN_SRC zig -i :exports code :tangle src/01/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 2
We start by reading the input line by line, where "lines" are
separated by commas. The each line is split into two parts separated by "-".

#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
const std = @import("std");
const aoc = @import("aoc");

const powi = std.math.powi;

pub fn run(allocator: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    lines.delimiter = ',';

    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const alloc = arena.allocator();

    var score1: u64 = 0;
    // invalid ids for part 2
    var invalids: std.ArrayList(u64) = .empty;

    while (try lines.next()) |rng| {
        const toks = try aoc.splitN(2, std.mem.trim(u8, rng, " \t\r\n"), "-");
#+END_SRC
Next we determine the number of digits of both numbers as well as
the numbers themselves.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
        const d1 = toks[0].len;
        const d2 = toks[1].len;

        const x = try std.fmt.parseUnsigned(u64, toks[0], 10);
        const y = try std.fmt.parseUnsigned(u64, toks[1], 10);
#+END_SRC
The idea is now to try each possible block size ~d~, which is used to
built the repeated patterns. The minimal possible block size is 1, the
maximal block size is $\lceil d_2/2 \rceil$ because we have to use at
least two blocks.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
        for (1..d2 / 2 + 1) |d| {
#+END_SRC
For a given block size ~d~ we compute a corresponding block
factor ~f~ by $f=10^d$.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
            const f = try powi(u64, 10, d); // block size as 10^d
#+END_SRC
Furthermore we compute the minimal and the maximal /number/ of blocks
(each of size ~d~) to be used. The minimal number is used to form ~x~, the
maximal number to form ~y~, hence
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
            const k_min = @max(2, (d1 - 1) / d + 1); // minimal number of blocks
            const k_max = d2 / d; // maximal number of blocks

            for (k_min..k_max + 1) |k| {
#+END_SRC
Now, for a given block size ~d~ and block count ~k~ we can construct all
possible numbers following the repeated pattern. Let ~z~ be value
representing one block. Then the repeated number can be computed
as \[z \cdot f^0 + z \cdot f^1 + \ldots + z \cdot f^{k-1} = z \cdot
\sum_{i=0}^{k-1} f^i\]
Using
\[ q = \sum_{i=0}^{k-1} f^i = \frac{f^k - 1}{f - 1} \]
the number is exactly $z \cdot q$.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                // block multiplicator
                const q = (try powi(u64, f, k) - 1) / (f - 1);
#+END_SRC
A valid block value must not be smaller than $\lceil x / q \rceil$ and not be
larger than $\lfloor y / q \rfloor$. Furthermore, because a block
must not start with a leading zero, the minimal possible block value
is \[f / 10 = \underbrace{10\ldots 0}_{d\text{ digits}}\]
and the maximal value is
\[f - 10 = \underbrace{99\ldots 9}_{d\text{ digits}}.\] Hence, we
can compute the minimal and maximal possible block values by
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                // minimal value based on x and on block-size (no leading zeros)
                const a = @max((x - 1) / q + 1, f / 10);
                // maximal value based on y and on block-size (no leading zeros)
                const b = @min(y / q, f - 1);
#+END_SRC
If the interval is empty, there is nothing to do
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                if (a > b) continue;
#+END_SRC
For part 1 we only consider the case of exactly two blocks. In that
case we compute the sum of all possible numbers formed by blocks in
$\{a, \ldots, b\}$, i.e.
\[ \sum_{z=a}^b z \cdot q = q \cdot \sum_{z=a}^b z = q \cdot \frac{b(b+1) - a(a-1)}2. \]
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                if (k == 2) {
                    // all values in between match (hopefully)
                    score1 += (b * (b + 1) - a * (a - 1)) / 2 * q;
                }
#+END_SRC
For part 2 we simply collect all invalid ids
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
                // because there may be duplicates, we simply count
                var z = a;
                while (z <= b) : (z += 1) try invalids.append(alloc, z * q);
            }
        }
    }
#+END_SRC
The remaining step is to sum the invalid ids for part2. We must take
care of possible duplicate values, i.e. some numbers can be found by
different block sizes (e.g. an invalid id ~111111111~ is found by block
sizes 1, 2 and 4). Therefore, we sort the invalid ids and
count each one only if it differs from its predecessor in the ordered
list:
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
    aoc.sort(u64, invalids.items);
    var score2: u64 = if (invalids.items.len == 0) 0 else invalids.items[0];
    for (invalids.items[0 .. invalids.items.len - 1], invalids.items[1..]) |x, y| {
        if (x != y) score2 += y;
    }
#+END_SRC
That's is, we can return the results.
#+BEGIN_SRC zig -i :exports code :tangle src/02/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 3
The main observation is that the most significant digit of a number
must be as large as possible. Hence, we can choose the most
significant digit such that it is as large as possible as long as
there are sufficiently many remaining digits to the right.

We start again be reading the input line by line and ensure it has
enough digits for part 2.
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(_: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var score1: u64 = 0;
    var score2: u64 = 0;
    while (try lines.next()) |line| {
        if (line.len < 12) return error.LineTooShort;
#+END_SRC
For part 1 we look for the first occurrence of the largest digit
except for the last digit in that line (because that one cannot be the
first of two digits in the result).
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        const i = std.mem.indexOfMax(u8, line[0 .. line.len - 1]);
#+END_SRC
Next we look for the largest digit to the right of the first one
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        const j = std.mem.indexOfMax(u8, line[i + 1 ..]) + i + 1;
#+END_SRC
And we can already compute the result for part 1 using these two digits
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        score1 += (line[i] - '0') * 10 + (line[j] - '0');
#+END_SRC

For part 2 we use the same strategy, but we have to ensure that there
are enough remaining digits to the right. So for the first digit
we do not look at the last 11 digits in that line. For the second
digit we do not look at the last 10 digits in that line and so on.
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
        var start: usize = 0;
        for (0..12) |k| {
            const idx = std.mem.indexOfMax(u8, line[start .. line.len - 11 + k]) + start;
            start = idx + 1; // for the next digit start to the right of this one
#+END_SRC
We can add each digit to the result immediately because the \((k+1)\)-th
most significant digit ~x~ contributes exactly $x \cdot 10^{11-k}$ to
the final sum.
#+BEGIN_SRC zig -i :exports code :tangle src/03/run.zig
            score2 += try std.math.powi(u64, 10, 11 - k) * (line[idx] - '0');
        }
    }

    return .{ score1, score2 };
}
#+END_SRC

* Day 4
We start by reading the input grid. In order to simplify the computation, we add
a boundary of empty squares.
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(alloc: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var arena = std.heap.ArenaAllocator.init(alloc);
    defer arena.deinit();
    const a = arena.allocator();

    // read grid with boundary of empty squares
    var g = try lines.readGridWithBoundary(a, '.');
#+END_SRC
Now we compute for each square the number of ~@~ neighbors (including
itself). For empty squares we set the number of neighbors to something
large. This allows us to recognize (and ignore) empty squares later by
only looking at that square's degree. Squares with degree < 4 can be
removed. We collect all of them in a list ~removable~.
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    var degrees = try aoc.Grid.initWith(a, g.n, g.m, 42);
    var removable: std.ArrayList(aoc.Pos) = .empty;
    for (1..g.n - 1) |i| {
        for (1..g.m - 1) |j| {
            if (g.at(i, j) == '@') {
                var d: u8 = 0;
                for (i - 1..i + 2) |y| {
                    for (j - 1..j + 2) |x| {
                        if (g.at(y, x) == '@') d += 1;
                    }
                }
                degrees.set(i, j, d);
                // d - 1 because we count the square itself
                if (d - 1 < 4) try removable.append(a, .{ .i = i, .j = j });
            }
        }
    }
#+END_SRC
The number of removable squares is already the score for part 1.
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    const score1 = removable.items.len;
#+END_SRC
For part 2 we remove the removable squares one by one. When we remove
a square we update the degrees of all of its neighbors (i.e. we reduce
the neighbor's degree by one each). If the degree of a neighbor drops
below 4 for the first time, that square can be removed as well, so it
is appended to the list of removable squares. 
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    var score2: usize = 0;
    while (removable.pop()) |pos| {
        score2 += 1; // the score is the number of all removed squares
        const i = pos.i;
        const j = pos.j;
        for (i - 1..i + 2) |y| {
            for (j - 1..j + 2) |x| {
                const deg = degrees.at(y, x);
                if (deg - 1 == 4) {
                    // degree drops below 4, so remove this
                    // neighbor as well
                    try removable.append(a, .{ .i = y, .j = x });
                    // mark this square as empty
                }
                degrees.set(y, x, deg - 1);
            }
        }
    }
#+END_SRC
That's it, we can return the solution
#+BEGIN_SRC zig -i :exports code :tangle src/04/run.zig
    return .{ score1, score2 };
}
#+END_SRC

* Day 5
The main idea is too keep all "interesting" numbers in a single ordered list.
Interesting numbers are
- start of an interval
- end of an interval
- id of an ingredient
We then order this list of numbers are traverse is from smallest to
largest. At the same time we keep track of the number of "open"
intervals, i.e. of those intervals whose start has already been seen
but whose end has not been seen, yet. If we find an "id", we can
easily check if it is contained in one currently open interval.

Several of these numbers may be equal. We need to distinguish if a
number is start or end of an interval or if it is an id. Furthermore,
because the intervals are inclusive, we have to ensure that we always
see interval starts first, then the id and then the interval ends. For
this we do not store a number $x$ itself in the list but $x \cdot f + c$
where $f$ is an integer at least 3 and $c$ is either 0, 1 or 2 depending on
if $x$ is a interval start, id or interval end, respectively.

We start by reading the intervals and append all numbers to the list ~nums~
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
const std = @import("std");
const aoc = @import("aoc");

pub fn run(alloc: std.mem.Allocator, lines: *aoc.Lines) ![2]u64 {
    var arena = std.heap.ArenaAllocator.init(alloc);
    defer arena.deinit();
    const a = arena.allocator();

    const F = 4;
    var nums: std.ArrayList(u64) = .empty;
    while (try lines.next()) |line| {
        if (line.len == 0) break; // stop at the first empty line
        const ns = try aoc.toNums(u64, 2, line, "-");
        try nums.append(a, ns[0] * F); // opening
        try nums.append(a, ns[1] * F + 2); // closing
        if (ns[0] > ns[1]) return error.InvalidRange;
    }
#+END_SRC
Next we read the list of ids and append them as well
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
    while (try lines.next()) |line| {
        const id = try aoc.toNum(u64, line);
        try nums.append(a, id * F + 1); // id
    }
#+END_SRC
Now we sort the list of numbers
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
    aoc.sort(u64, nums.items);
#+END_SRC
and traverse them in order. While doing so we keep track of the number
of open intervals ~nopen~ at the current point as well as start of the
first currently open interval ~start~.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
    var score1: usize = 0;
    var score2: u64 = 0;
    var nopen: usize = 0;
    var start: u64 = 0;
    for (nums.items) |x| {
#+END_SRC
If the number is an interval start, we increase the number of open
intervals and possibly store the start position (if it is the first
open interval).
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
        if (x % F == 0) {
            if (nopen == 0) start = x / F;
            nopen += 1;
#+END_SRC
If the number is an interval end, we decrease the number of open
intervals. If it is the last open interval, we know that all
numbers from ~start~ to the current position are "fresh" and we
add their count to the score of part 2.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
        } else if (x % F == 2) {
            nopen -= 1;
            if (nopen == 0) score2 += (x / F - start + 1);
#+END_SRC
Otherwise the number is an id. If there is currently at least one open
interval, the id is "fresh" and we increment the score for part 1.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig
        } else if (nopen > 0) {
            score1 += 1;
        }
    }
#+END_SRC
That's it, we return the results.
#+BEGIN_SRC zig -i :exports code :tangle src/05/run.zig

    return .{ score1, score2 };
}
#+END_SRC

# Local Variables:
# jinx-languages: "en_US"
# End:
